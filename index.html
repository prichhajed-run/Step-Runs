<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>Run Tracker ‚Äî Graphs & Splits</title>
<link rel="stylesheet" href="https://unpkg.com/leaflet/dist/leaflet.css" />
<style>
body { font-family: Arial, sans-serif; margin:0; padding:12px; background:#f7f7f7; color:#111; }
h1 { text-align:center; color:#0a4; margin:0 0 10px 0; }
.controls { text-align:center; margin-bottom:8px; }
button { margin:6px 6px; padding:10px 14px; font-size:15px; border-radius:7px; border:none; background:#007bff; color:white; cursor:pointer; }
button.secondary { background:#6c757d; }
#map { height:360px; border-radius:8px; overflow:hidden; border:1px solid #ddd; margin-bottom:10px; position:relative; }
.leaflet-top.leaflet-right .map-info { margin-top:8px; }
.map-info {
  background: rgba(255,255,255,0.95);
  padding:8px 10px;
  border-radius:6px;
  box-shadow: 0 2px 6px rgba(0,0,0,0.12);
  font-size:13px;
  min-width:150px;
}
.map-info b { display:block; margin-bottom:4px; }
.tabs { display:flex; margin-bottom:10px; }
.tab { flex:1; padding:10px; text-align:center; cursor:pointer; background:#eee; border-radius:6px 6px 0 0; margin-right:2px; }
.tab.active { background:#fff; border-bottom:1px solid #fff; }
.tab-content { background:#fff; border-radius:0 0 8px 8px; padding:10px; min-height:200px; border:1px solid #ddd; }
.stats-row { display:flex; flex-wrap:wrap; gap:8px; justify-content:center; }
.stat { min-width:110px; padding:8px 10px; border-radius:6px; background:#fafafa; font-size:14px; text-align:center; box-shadow:0 0 0 1px rgba(0,0,0,0.03) inset; }
#splitsTable { width:100%; border-collapse:collapse; font-size:13px; }
#splitsTable th, #splitsTable td { border:1px solid #eee; padding:8px; text-align:center; }
#splitsTable th { background:#f3f3f3; font-weight:600; }
.chart-wrap { width:100%; height:200px; margin-bottom:12px; }
canvas.chart-canvas { width:100% !important; height:100% !important; display:block; }
.gps-legend { font-size:12px; margin-top:6px; color:#333; }
.gps-badge { display:inline-block; padding:3px 7px; border-radius:999px; font-weight:600; margin-left:6px; }
.gps-verygood { background:#2ecc71; color:#fff; }
.gps-good { background:#f1c40f; color:#fff; }
.gps-fair { background:#e67e22; color:#fff; }
.gps-poor { background:#e74c3c; color:#fff; }
@media (max-width:520px){ #map{height:240px;} .stat{min-width:90px; font-size:13px;} }
</style>
</head>
<body>

<h1>üèÉ Run Tracker</h1>

<div class="controls">
  <button id="btnStart">‚ñ∂ Start</button>
  <button id="btnPause" class="secondary">‚è∏ Pause</button>
  <button id="btnReset" class="secondary">üîÑ Reset</button>
  <button id="btnSave">üì∏ Save Summary</button>
</div>

<div id="map"></div>

<div class="tabs">
  <div class="tab active" data-tab="stats">Stats</div>
  <div class="tab" data-tab="graphs">Graphs</div>
  <div class="tab" data-tab="splits">Splits</div>
</div>

<div id="stats" class="tab-content">
  <div class="stats-row">
    <div class="stat">Time<br><strong id="time">0:00</strong></div>
    <div class="stat">Distance<br><strong id="distance">0.00</strong> km</div>
    <div class="stat">Live Pace<br><strong id="livepace">0:00</strong> min/km</div>
    <div class="stat">Avg Pace<br><strong id="avgpace">0:00</strong> min/km</div>
    <div class="stat">Steps<br><strong id="steps">0</strong></div>
    <div class="stat">Avg Cadence<br><strong id="cadence">0</strong> spm</div>
    <div class="stat">Avg Stride<br><strong id="stride">0</strong> cm</div>
    <div class="stat">Elev Gain<br><strong id="elevation">0</strong> m</div>
  </div>
</div>

<div id="graphs" class="tab-content" style="display:none;">
  <div class="chart-wrap"><canvas id="distanceChart" class="chart-canvas"></canvas></div>
  <div class="chart-wrap"><canvas id="timeChart" class="chart-canvas"></canvas></div>
</div>

<div id="splits" class="tab-content" style="display:none;">
  <div id="splitsList"><em>No splits yet</em></div>
</div>

<!-- Scripts -->
<script src="https://unpkg.com/leaflet/dist/leaflet.js"></script>
<script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/html2canvas/1.4.1/html2canvas.min.js"></script>
<script src="https://unpkg.com/leaflet-image/leaflet-image.js"></script>
<script>
/* --------------------------
   Map
-------------------------- */
let map = L.map('map', { attributionControl:false }).setView([20.5937,78.9629],5);
L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png',{ maxZoom:19 }).addTo(map);
let path = L.polyline([], { color:'red', weight:4, opacity:0.9 }).addTo(map);

let gpsMarker = null;
let accuracyCircle = null;
let gpsInfoControl = null;
let lastReverseGeocodeTs = 0;
const REVERSE_GEOCODE_MIN_MS = 15000; // 15s throttle

gpsInfoControl = L.control({ position: 'topright' });
gpsInfoControl.onAdd = function () {
  const div = L.DomUtil.create('div', 'map-info');
  div.innerHTML = `
    <b>GPS</b>
    <div>Accuracy: <span id="gpsAccuracy">‚Äî</span> m <span id="gpsBadge" class="gps-badge"></span></div>
    <div>Strength: <span id="gpsStrength">‚Äî</span></div>
    <div>Place: <span id="gpsPlace">‚Äî</span></div>
    <div class="gps-legend"><small>Accuracy circle shown on map</small></div>
  `;
  L.DomEvent.disableClickPropagation(div);
  return div;
};
gpsInfoControl.addTo(map);

/* --------------------------
   State
-------------------------- */
let running=false, paused=false, startTime=0, elapsed=0, timer=null;
let lastPos=null, lastUpdateTime=null;
let gpsDistance=0, blendedDistance=0;
let prevBlendedDistance=0, prevElapsedTime=0, prevStepCount=0;
let stepCount=0, lastStepTime=0, lastAccel=0;
let splits=[], lastSplit=0, lastSplitTime=0;
let defaultStride=0.78, estimatedStride=defaultStride;
let elevationGain=0, lastAltitude=null;
let watchId=null;
let recentDistances=[];

const LIVE_PACE_WINDOW_SEC = 10;
const MIN_MOVE_THRESHOLD_M = 1.0;
const MAX_VALID_SPEED_MPS = 6.0;
const MAX_ACCEPTABLE_ACCURACY_M = 20;

/* --------------------------
   Charts
-------------------------- */
const distanceCtx=document.getElementById('distanceChart').getContext('2d');
const timeCtx=document.getElementById('timeChart').getContext('2d');

const distanceChart = new Chart(distanceCtx,{
  type:'line',
  data:{ labels:[], datasets:[{ label:'Pace (min/km)', data:[], borderColor:'#1f77b4', tension:0.3, fill:false }] },
  options:{ responsive:true, maintainAspectRatio:false,
    scales:{ x:{ title:{ display:true, text:'Distance (m)'} }, y:{ title:{ display:true, text:'Pace (min/km)'} } }
  }
});
const timeChart = new Chart(timeCtx,{
  type:'line',
  data:{ labels:[], datasets:[{ label:'Pace (min/km)', data:[], borderColor:'#2ca02c', tension:0.3, fill:false }] },
  options:{ responsive:true, maintainAspectRatio:false,
    scales:{ x:{ title:{ display:true, text:'Time (min)'} }, y:{ title:{ display:true, text:'Pace (min/km)'} } }
  }
});

/* --------------------------
   Tabs
-------------------------- */
document.querySelectorAll('.tab').forEach(tab=>{
  tab.onclick=()=>{
    document.querySelectorAll('.tab').forEach(t=>t.classList.remove('active'));
    document.querySelectorAll('.tab-content').forEach(c=>c.style.display='none');
    tab.classList.add('active');
    const el=document.getElementById(tab.dataset.tab);
    el.style.display='block';
    if(tab.dataset.tab==='graphs'){
      setTimeout(()=>{ distanceChart.resize(); distanceChart.update(); timeChart.resize(); timeChart.update(); },150);
    }
    if(tab.dataset.tab==='stats') setTimeout(()=>map.invalidateSize(),200);
  }
});

/* --------------------------
   Helpers
-------------------------- */
function pad2(n){ return (n<10?'0':'')+n; }
function formatSeconds(sec){ sec=Math.round(sec); let m=Math.floor(sec/60), s=sec%60; return pad2(m)+':'+pad2(s); }
function mmssFromMinutes(mins){ let m=Math.floor(mins), s=Math.round((mins-m)*60); return pad2(m)+':'+pad2(s); }
function getStrengthLabelFromAccuracy(acc){
  if(acc === null || typeof acc === 'undefined') return { label:'Unknown', cls:'' };
  if(acc <= 5) return { label: 'Excellent', cls: 'gps-verygood' };
  if(acc <= 10) return { label: 'Good', cls: 'gps-good' };
  if(acc <= 20) return { label: 'Fair', cls: 'gps-fair' };
  return { label: 'Poor', cls: 'gps-poor' };
}

/* --------------------------
   UI
-------------------------- */
function updateUIAll(){
  document.getElementById('time').innerText=formatSeconds(elapsed/1000);
  document.getElementById('distance').innerText=(blendedDistance/1000).toFixed(2);
  let avgPace=(blendedDistance>0)?(elapsed/60000)/(blendedDistance/1000):0;
  document.getElementById('avgpace').innerText=avgPace>0?mmssFromMinutes(avgPace):'0:00';

  let nowTs = Date.now();
  let windowMs = LIVE_PACE_WINDOW_SEC*1000;
  let distSum = 0, timeSum = 0;
  for(let i=recentDistances.length-1;i>=0;i--){
    const item = recentDistances[i];
    const age = nowTs - item.ts;
    if(age <= windowMs){ distSum += item.d; timeSum += item.t; }
    else{ const overlap = Math.max(0, windowMs - (nowTs - item.ts) + item.t); if(overlap>0 && item.t>0){ distSum += item.d * overlap/item.t; } break; }
  }
  let livePace = avgPace;
  if(distSum>0 && timeSum>0){ livePace = (timeSum/60000)/(distSum/1000); }
  document.getElementById('livepace').innerText=livePace>0?mmssFromMinutes(livePace):'0:00';

  document.getElementById('steps').innerText=stepCount;
  document.getElementById('cadence').innerText=Math.round(elapsed>0?stepCount/(elapsed/60000):0);
  document.getElementById('stride').innerText=Math.round(stepCount>0?blendedDistance/stepCount*100:0);
  document.getElementById('elevation').innerText=Math.round(elevationGain);
}

function renderSplits(){
  if(splits.length===0){ document.getElementById('splitsList').innerHTML='<em>No splits yet</em>'; return; }
  let html = '<table id="splitsTable"><thead><tr><th>Distance (m)</th><th>Time (s)</th><th>Steps</th></tr></thead><tbody>';
  for(let i=0;i<splits.length;i++){
    const s = splits[i];
    html += `<tr><td>${s.m}</td><td>${Math.round(s.time)}</td><td>${s.steps}</td></tr>`;
  }
  html += '</tbody></table>';
  document.getElementById('splitsList').innerHTML = html;
}

/* --------------------------
   Motion
-------------------------- */
function handleMotion(e){
  const acc=e.accelerationIncludingGravity||{x:0,y:0,z:0};
  let mag=Math.sqrt((acc.x||0)**2+(acc.y||0)**2+(acc.z||0)**2);
  let delta=Math.abs(mag-lastAccel); lastAccel=mag;
  if(delta>1.2 && mag>9 && Date.now()-lastStepTime>300){ stepCount++; lastStepTime=Date.now(); }
}

/* --------------------------
   Run control
-------------------------- */
document.getElementById('btnStart').onclick=startRun;
document.getElementById('btnPause').onclick=pauseRun;
document.getElementById('btnReset').onclick=resetRun;

function startRun(){
  if(running && paused){ paused=false; startTime=Date.now()-elapsed; timer=setInterval(()=>{ elapsed=Date.now()-startTime; updateUIAll(); },1000); setupMotionListener(); setupGeolocationWatch(); return; }
  running=true; paused=false; startTime=Date.now(); elapsed=0;
  lastPos=null; lastUpdateTime=null; gpsDistance=0; blendedDistance=0;
  prevBlendedDistance=0; prevElapsedTime=0; prevStepCount=0;
  stepCount=0; splits=[]; lastSplit=0; lastSplitTime=0; estimatedStride=defaultStride;
  elevationGain=0; lastAltitude=null; recentDistances=[]; path.setLatLngs([]);
  distanceChart.data.labels=[]; distanceChart.data.datasets[0].data=[]; distanceChart.update();
  timeChart.data.labels=[]; timeChart.data.datasets[0].data=[]; timeChart.update();
  renderSplits(); updateUIAll();
  setupMotionListener(); setupGeolocationWatch();
  timer=setInterval(()=>{ elapsed=Date.now()-startTime; updateUIAll(); },1000);
}
function pauseRun(){ if(!running||paused) return; paused=true; clearInterval(timer); timer=null; removeMotionListener(); clearGeoWatch(); }
function resetRun(){ running=false; paused=false; clearInterval(timer); timer=null; removeMotionListener(); clearGeoWatch();
  lastPos=null; lastUpdateTime=null; gpsDistance=0; blendedDistance=0;
  prevBlendedDistance=0; prevElapsedTime=0; prevStepCount=0;
  stepCount=0; splits=[]; lastSplit=0; lastSplitTime=0; estimatedStride=defaultStride;
  elevationGain=0; lastAltitude=null; recentDistances=[]; path.setLatLngs([]);
  distanceChart.data.labels=[]; distanceChart.data.datasets[0].data=[]; distanceChart.update();
  timeChart.data.labels=[]; timeChart.data.datasets[0].data=[]; timeChart.update();
  updateUIAll(); renderSplits(); map.setView([20.5937,78.9629],5);
  if(gpsMarker){ map.removeLayer(gpsMarker); gpsMarker=null; }
  if(accuracyCircle){ map.removeLayer(accuracyCircle); accuracyCircle=null; }
  document.getElementById('gpsAccuracy').innerText='‚Äî';
  document.getElementById('gpsStrength').innerText='‚Äî';
  document.getElementById('gpsBadge').innerText='';
  document.getElementById('gpsBadge').className='gps-badge';
  document.getElementById('gpsPlace').innerText='‚Äî';
}

function setupMotionListener(){ try{ if(typeof DeviceMotionEvent!=='undefined' && typeof DeviceMotionEvent.requestPermission==='function'){ DeviceMotionEvent.requestPermission().then(res=>{ if(res==='granted') window.addEventListener('devicemotion', handleMotion); }); } else window.addEventListener('devicemotion', handleMotion); }catch(e){ console.warn(e); } }
function removeMotionListener(){ try{ window.removeEventListener('devicemotion', handleMotion); }catch(e){} }
function setupGeolocationWatch(){ if(!navigator.geolocation) return; if(watchId!==null){ try{ navigator.geolocation.clearWatch(watchId); }catch(e){} watchId=null; } watchId=navigator.geolocation.watchPosition(onPosition,onError,{enableHighAccuracy:true,maximumAge:1000,timeout:10000}); }
function clearGeoWatch(){ if(watchId!==null && navigator.geolocation){ try{ navigator.geolocation.clearWatch(watchId); }catch(e){} watchId=null; }}

/* --------------------------
   Reverse geocode
-------------------------- */
function reverseGeocode(lat, lon){
  const now = Date.now();
  if(now - lastReverseGeocodeTs < REVERSE_GEOCODE_MIN_MS) return;
  lastReverseGeocodeTs = now;
  fetch(`https://nominatim.openstreetmap.org/reverse?format=jsonv2&lat=${lat}&lon=${lon}`, { headers: { 'Accept': 'application/json' } })
    .then(r=>r.ok? r.json() : Promise.reject('no-rev'))
    .then(data=>{
      let place='Unknown';
      if(data && data.address){ place=data.address.city||data.address.town||data.address.village||data.address.suburb||data.address.locality||data.address.county||data.display_name||'Unknown'; }
      else if(data && data.display_name) place=data.display_name;
      document.getElementById('gpsPlace').innerText = place;
    }).catch(err=>{});
}

/* --------------------------
   GPS / splits (fixed blendedDistance)
-------------------------- */
function onPosition(pos){
  const lat=pos.coords.latitude, lon=pos.coords.longitude, now=Date.now();
  const acc = (typeof pos.coords.accuracy === 'number') ? pos.coords.accuracy : null;
  updateMapLocation(lat, lon, acc);

  if(typeof pos.coords.altitude==='number'){
    if(lastAltitude===null) lastAltitude=pos.coords.altitude;
    if(pos.coords.altitude>lastAltitude) elevationGain+=pos.coords.altitude-lastAltitude;
    lastAltitude=pos.coords.altitude;
  }

  // Update blendedDistance using steps as fallback if GPS is poor
  let validGPS = acc !== null && acc <= MAX_ACCEPTABLE_ACCURACY_M;
  let d=0;
  if(lastPos && validGPS){
    d = haversine_m(lastPos.lat,lastPos.lon,lat,lon);
    let deltaT = Math.max((now-lastUpdateTime)/1000,0.001);
    let speed = d/deltaT;
    if(d<MIN_MOVE_THRESHOLD_M || speed>MAX_VALID_SPEED_MPS) d=0;
    gpsDistance += d;
    lastUpdateTime=now;
    lastPos={lat,lon};
  } else if(!lastPos){
    lastPos={lat,lon}; lastUpdateTime=now;
  }

  // blendedDistance = max(GPS, steps*stride)
  estimatedStride = stepCount>0?Math.max(0.3,Math.min(2.5,gpsDistance/stepCount)):defaultStride;
  blendedDistance = Math.max(gpsDistance, stepCount*estimatedStride);

  // recentDistances for live pace
  recentDistances.push({d: d, t: 1000, ts: now});
  if(recentDistances.length>500) recentDistances.shift();

  // handle 100m splits
  const prevDist = prevBlendedDistance, currDist = blendedDistance;
  const segmentDist = currDist-prevDist;
  const segmentTime = elapsed/1000 - prevElapsedTime;
  const segmentSteps = stepCount-prevStepCount;
  if(segmentDist>0.0001){
    let nextTarget = Math.floor(lastSplit/100+1)*100;
    while(nextTarget<=Math.floor(currDist)){
      const ratio = Math.max(0, Math.min(1, (nextTarget-prevDist)/segmentDist));
      const splitAbsoluteTime = prevElapsedTime + ratio*segmentTime;
      const stepsAtTarget = prevStepCount + Math.round(ratio*segmentSteps);
      const splitDuration = Math.max(0.0001, splitAbsoluteTime-lastSplitTime);
      const splitSteps = stepsAtTarget-(splits.length>0?splits[splits.length-1].cumulativeSteps||0:0);
      splits.push({m: nextTarget, time: splitDuration, steps: Math.max(0, splitSteps), cumulativeSteps: stepsAtTarget});
      renderSplits();
      const paceMinPerKm = splitDuration/6;
      distanceChart.data.labels.push(nextTarget);
      distanceChart.data.datasets[0].data.push(Number(paceMinPerKm.toFixed(2)));
      timeChart.data.labels.push(Number((splitAbsoluteTime/60).toFixed(2)));
      timeChart.data.datasets[0].data.push(Number(paceMinPerKm.toFixed(2)));
      lastSplit=nextTarget;
      lastSplitTime=splitAbsoluteTime;
      nextTarget+=100;
    }
  }
  prevBlendedDistance = blendedDistance;
  prevElapsedTime = elapsed/1000;
  prevStepCount = stepCount;

  // Update GPS info UI
  document.getElementById('gpsAccuracy').innerText = (acc !== null ? acc.toFixed(1) : '‚Äî');
  const st = getStrengthLabelFromAccuracy(acc);
  document.getElementById('gpsStrength').innerText = st.label;
  const badge = document.getElementById('gpsBadge');
  badge.innerText = st.label;
  badge.className = 'gps-badge ' + (st.cls || '');
  reverseGeocode(lat, lon);
  updateUIAll();
  distanceChart.update();
  timeChart.update();
}

function onError(e){ console.warn(e); }

function updateMapLocation(lat, lon, accuracy){
  if(!gpsMarker){ gpsMarker=L.circleMarker([lat,lon],{ radius:6,color:'#0066cc', fillColor:'#fff', weight:2, fillOpacity:1 }).addTo(map); }
  else gpsMarker.setLatLng([lat,lon]);
  if(accuracy && !isNaN(accuracy)){
    if(!accuracyCircle){ accuracyCircle=L.circle([lat,lon],{ radius: accuracy, color:'#3388ff', fillColor:'#3388ff', fillOpacity:0.08, weight:1 }).addTo(map); }
    else { accuracyCircle.setLatLng([lat,lon]); accuracyCircle.setRadius(accuracy); }
  } else { if(accuracyCircle){ map.removeLayer(accuracyCircle); accuracyCircle=null; } }
}

function haversine_m(lat1, lon1, lat2, lon2){ const R=6371000; const toRad=x=>x*Math.PI/180; let dLat=toRad(lat2-lat1), dLon=toRad(lon2-lon1); let a=Math.sin(dLat/2)**2+Math.cos(toRad(lat1))*Math.cos(toRad(lat2))*Math.sin(dLon/2)**2; return R*2*Math.atan2(Math.sqrt(a), Math.sqrt(1-a)); }
</script>
</body>
</html>

